/*
 * Copyright (c) 2017 - Adjacent Link LLC, Bridgewater, New Jersey
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 * * Neither the name of Adjacent Link LLC nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * See toplevel COPYING for more information.
 */

#include "probe.h"
#include "otestpoint/toolkit/exception.h"
#include "otestpoint/toolkit/stringto.h"
#include "otestpoint/probeserviceuser.h"
#include "iptraffic.pb.h"

#include <libxml/parser.h>
#include <libxml/xmlschemas.h>
#include <pthread.h>
#include <net/ethernet.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <arpa/inet.h>

namespace
{
  const int PCAP_SNAPLEN = 0xFFFF;
  const int PCAP_PROMISC = 1;
  const int PCAP_TIMEOUT = 0;

  const char * pzSchema="\
<?xml version='1.0' encoding='UTF-8' standalone='yes'?>\
<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'>\
  <xs:element name='probe-iptraffic'>\
    <xs:complexType>\
      <xs:attribute name='device' type='xs:string' use='required'/>  \
    </xs:complexType>\
  </xs:element>\
</xs:schema>";
}


OpenTestPoint::IPTraffic::Probe::Probe(ProbeIndex probeIndex):
  ProbePlugin{probeIndex},
  pPcapHandle_{}
{}

OpenTestPoint::ProbeNames
OpenTestPoint::IPTraffic::Probe::initialize(const std::string & sConfigurationFile)
{
  LIBXML_TEST_VERSION;

  xmlDocPtr pSchemaDoc{xmlReadMemory(pzSchema,
                                     strlen(pzSchema),
                                     "file:///probe-iproute.xsd",
                                     NULL,
                                     0)};

  if(!pSchemaDoc)
    {
      throw Toolkit::Exception{"unable to open schema"};
    }

  xmlSchemaParserCtxtPtr pParserContext{xmlSchemaNewDocParserCtxt(pSchemaDoc)};

  if(!pParserContext)
    {
      throw Toolkit::Exception{"bad schema context"};
    }

  xmlSchemaPtr pSchema{xmlSchemaParse(pParserContext)};

  if(!pSchema)
    {
      throw Toolkit::Exception{"bad schema parser"};
    }

  xmlSchemaValidCtxtPtr pSchemaValidCtxtPtr{xmlSchemaNewValidCtxt(pSchema)};

  if(!pSchemaValidCtxtPtr)
    {
      throw Toolkit::Exception{"bad schema valid context"};
    }

  xmlSchemaSetValidOptions(pSchemaValidCtxtPtr,XML_SCHEMA_VAL_VC_I_CREATE);

  xmlDocPtr pDoc = xmlReadFile(sConfigurationFile.c_str(),nullptr,0);

  if(xmlSchemaValidateDoc(pSchemaValidCtxtPtr, pDoc))
    {
      throw Toolkit::Exception{"invalid document"};
    }

  xmlNodePtr pRoot = xmlDocGetRootElement(pDoc);

  xmlChar * pDeviceName = xmlGetProp(pRoot,BAD_CAST "device");

  sDevice_ = reinterpret_cast<const char *>(pDeviceName);

  xmlFree(pDeviceName);

  xmlFreeDoc(pDoc);

  probeNames_.push_back("IPTraffic.Tables.IPv4.UDP");

  OPENTESTPOINT_PROBESERVICE_LOG_INFO(pProbeService_,
                                      "creating IPTraffic probe on %s",
                                      sDevice_.c_str());

  return probeNames_;
}

void OpenTestPoint::IPTraffic::Probe::start()
{
  char errbuf[PCAP_ERRBUF_SIZE]={};

  // open pcap handle
  if((pPcapHandle_ = pcap_open_live(sDevice_.c_str(),
                                    PCAP_SNAPLEN,
                                    PCAP_PROMISC,
                                    PCAP_TIMEOUT,
                                    errbuf)) == NULL)
    {
      throw Toolkit::Exception{"could not open device:%s %s",
          sDevice_.c_str(),
          errbuf};
    }

  // set datalink type, this covers 10/100/1000
  if(pcap_set_datalink(pPcapHandle_, DLT_EN10MB) < 0)
    {
      OPENTESTPOINT_PROBESERVICE_LOG_INFO(pProbeService_,
                                          "could not set datalink type on device %s %s",
                                          sDevice_.c_str(),
                                          errbuf);
    }

  // currently unsupported by winpcap
  if(pcap_setdirection(pPcapHandle_, PCAP_D_IN) < 0)
    {
      throw Toolkit::Exception{"could not set direction on device %s %s",
          sDevice_.c_str(),
          errbuf};
    }

  // start pcap read thread
  thread_ = std::thread(&Probe::readDevice,this);
}

void OpenTestPoint::IPTraffic::Probe::stop()
{
  if(pPcapHandle_)
    {
      pthread_cancel(thread_.native_handle());

      thread_.join();

      pcap_close(pPcapHandle_);
    }
}

void OpenTestPoint::IPTraffic::Probe::destroy()
{}


OpenTestPoint::ProbeData OpenTestPoint::IPTraffic::Probe::probe()
{
  ProbeData probeData{};

  char addr[16] = {};

  auto msg = OpenTestPoint::Measurement_pcap_tables_ipv4_udp{};

  auto pReceive = msg.mutable_receive();

  pReceive->add_labels("Src");
  pReceive->add_labels("Dst");
  pReceive->add_labels("Port");
  pReceive->add_labels("Rx Bytes");
  pReceive->add_labels("Rx Packets");

  mutex_.lock();

  for(const auto & entry : store_)
    {
      auto pRow = pReceive->add_rows();

      auto pValue = pRow->add_values();

      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_STRING);

      inet_ntop(AF_INET,
                &std::get<0>(entry.first),
                addr,
                sizeof(addr));

      pValue->set_svalue(addr);

      pValue = pRow->add_values();

      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_STRING);

      inet_ntop(AF_INET,
                &std::get<1>(entry.first),
                addr,
                sizeof(addr));

      pValue->set_svalue(addr);

      pValue = pRow->add_values();

      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_UINTEGER);

      pValue->set_uvalue(ntohs(std::get<2>(entry.first)));

      pValue = pRow->add_values();

      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_UINTEGER);

      pValue->set_uvalue(std::get<0>(entry.second));

      pValue = pRow->add_values();

      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_UINTEGER);

      pValue->set_uvalue(std::get<1>(entry.second));
    }

  mutex_.unlock();

  std::string sBlob{};

  msg.SerializeToString(&sBlob);


  probeData.push_back(std::make_tuple("IPTraffic.Tables.IPv4.UDP",
                                      std::move(sBlob),
                                      msg.description().name(),
                                      msg.description().module(),
                                      msg.description().version()));

  return probeData;
}

OpenTestPoint::IPTraffic::Probe::~Probe()
{}

void OpenTestPoint::IPTraffic::Probe::readDevice()
{
  const std::uint8_t * buf = NULL;

  struct pcap_pkthdr *pcap_hdr = NULL;

  int iPcapResult{};

  while(1)
    {
      // get frame, blocks here
      iPcapResult = pcap_next_ex(pPcapHandle_, &pcap_hdr, &buf);

      // error
      if(iPcapResult < 0)
        {
          OPENTESTPOINT_PROBESERVICE_LOG_ERROR(pProbeService_,
                                               "pcap_next_ex error %s",
                                               pcap_geterr(pPcapHandle_));

          // done
          break;
        }
      // time out
      else if(iPcapResult == 0)
        {
          continue;
        }
      // success
      else if(iPcapResult == 1)
        {
          if(ETHER_IS_VALID_LEN(pcap_hdr->caplen))
            {
              // eth header
              const ether_header * pEthHeader = reinterpret_cast<const ether_header *>(buf);

              switch(ntohs(pEthHeader->ether_type))
                {
                case ETHERTYPE_IP:
                  {
                    const iphdr * pIPHeader =
                      reinterpret_cast<const iphdr *>(buf + ETHER_HDR_LEN);

                    switch(pIPHeader->protocol)
                      {
                      case IPPROTO_UDP:
                        {
			  // ihl in units of 32-bit words. convert to bytes.
                          const udphdr * pUDPHeader =
                            reinterpret_cast<const udphdr *>(buf + ETHER_HDR_LEN  + (pIPHeader->ihl*4));


                          mutex_.lock();

                          auto iter = store_.find(std::make_tuple(pIPHeader->saddr,
                                                                  pIPHeader->daddr,
                                                                  pUDPHeader->dest));

                          if(iter != store_.end())
                            {
                              // bytes
                              std::get<0>(iter->second) += ntohs(pUDPHeader->len);

                              // packets
                              ++std::get<1>(iter->second);
                            }
                          else
                            {
                              store_.insert({std::make_tuple(pIPHeader->saddr,
                                                             pIPHeader->daddr,
                                                             pUDPHeader->dest),
                                    std::make_tuple(ntohs(pUDPHeader->len),1)});
                            }

                          mutex_.unlock();

                          break;
                        }
                      }
                  }
                }
            }
        }
    }
}

DECLARE_PROBEPLUGIN(OpenTestPoint::IPTraffic::Probe)
