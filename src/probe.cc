/*
 * Copyright (c) 2017 - Adjacent Link LLC, Bridgewater, New Jersey
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 * * Neither the name of Adjacent Link LLC nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * See toplevel COPYING for more information.
 */

#include "probe.h"
#include "otestpoint/toolkit/exception.h"
#include "otestpoint/toolkit/stringto.h"
#include "otestpoint/probeserviceuser.h"
#include "iptraffic.pb.h"

#include <libxml/parser.h>
#include <libxml/xmlschemas.h>
#include <pthread.h>
#include <net/ethernet.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <arpa/inet.h>

namespace
{
  const int PCAP_SNAPLEN = 0xFFFF;
  const int PCAP_PROMISC = 1;
  const int PCAP_TIMEOUT = 0;

  const char * pzSchema="\
<?xml version='1.0' encoding='UTF-8' standalone='yes'?>\
<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'>\
  <xs:element name='probe-iptraffic'>\
    <xs:complexType>\
      <xs:sequence>\
        <xs:element name='device' maxOccurs='unbounded' minOccurs='1'>\
          <xs:complexType>\
            <xs:simpleContent>\
              <xs:extension base='xs:string'>\
                <xs:attribute type='xs:string' name='name' use='required'/>\
              </xs:extension>\
            </xs:simpleContent>\
          </xs:complexType>\
        </xs:element>\
      </xs:sequence>\
    </xs:complexType>\
  </xs:element>\
</xs:schema>";
}


OpenTestPoint::IPTraffic::Probe::Probe(ProbeIndex probeIndex):
  ProbePlugin{probeIndex},
  vContexts_{}
{}

OpenTestPoint::ProbeNames
OpenTestPoint::IPTraffic::Probe::initialize(const std::string & sConfigurationFile)
{
  LIBXML_TEST_VERSION;

  xmlDocPtr pSchemaDoc{xmlReadMemory(pzSchema,
                                     strlen(pzSchema),
                                     "file:///probe-iproute.xsd",
                                     NULL,
                                     0)};

  if(!pSchemaDoc)
    {
      throw Toolkit::Exception{"unable to open schema"};
    }

  xmlSchemaParserCtxtPtr pParserContext{xmlSchemaNewDocParserCtxt(pSchemaDoc)};

  if(!pParserContext)
    {
      throw Toolkit::Exception{"bad schema context"};
    }

  xmlSchemaPtr pSchema{xmlSchemaParse(pParserContext)};

  if(!pSchema)
    {
      throw Toolkit::Exception{"bad schema parser"};
    }

  xmlSchemaValidCtxtPtr pSchemaValidCtxtPtr{xmlSchemaNewValidCtxt(pSchema)};

  if(!pSchemaValidCtxtPtr)
    {
      throw Toolkit::Exception{"bad schema valid context"};
    }

  xmlSchemaSetValidOptions(pSchemaValidCtxtPtr,XML_SCHEMA_VAL_VC_I_CREATE);

  xmlDocPtr pDoc = xmlReadFile(sConfigurationFile.c_str(),nullptr,0);

  if(xmlSchemaValidateDoc(pSchemaValidCtxtPtr, pDoc))
    {
      throw Toolkit::Exception{"invalid document"};
    }

  xmlNodePtr pRoot = xmlDocGetRootElement(pDoc);

  xmlNodePtr pChild = pRoot->xmlChildrenNode;
  xmlChar * pDeviceName = NULL;

  mutex_.lock();
  
  while(pChild != NULL) {
    if ((!xmlStrcmp(pChild->name, (const xmlChar *)"device"))) {
      pDeviceName = xmlGetProp(pChild,(const xmlChar *) "name");
      ProbeContext pc(std::string(reinterpret_cast<const char *>(pDeviceName)));
      vContexts_.push_back(pc);
      
      // lDevices_.push_back(reinterpret_cast<const char *>(pDeviceName));
      xmlFree(pDeviceName);
    }
    pChild = pChild->next;
    
  }
  mutex_.unlock();
  
  xmlFreeDoc(pDoc);

  // To-Do, check this name is accurate
  probeNames_.push_back("IPTraffic.Tables.IPv4.UDP");

  for(auto const& context: vContexts_){
    OPENTESTPOINT_PROBESERVICE_LOG_INFO(pProbeService_,
            "creating IPTraffic probe on %s",
            context.sDevice.c_str());
  }
  

  return probeNames_;
}

void OpenTestPoint::IPTraffic::Probe::start()
{
  char errbuf[PCAP_ERRBUF_SIZE]={};

  // open pcap handle
  for(auto & context: vContexts_){
    context.mutex.lock();
    
    const char* device = context.sDevice.c_str();
    
    pcap_t * pPcapHandle = pcap_open_live(device,
            PCAP_SNAPLEN,
            PCAP_PROMISC,
            PCAP_TIMEOUT,
            errbuf);
    
    if(pPcapHandle  == NULL )
    {
      throw Toolkit::Exception{"could not open device:%s %s",
          device,
          errbuf};
    }
    // no need for an "else" since the if throws
    context.pPcapHandle=pPcapHandle;

    // set datalink type, this covers 10/100/1000
    if(pcap_set_datalink(pPcapHandle, DLT_EN10MB) < 0)
    {
      OPENTESTPOINT_PROBESERVICE_LOG_INFO(pProbeService_,
              "could not set datalink type on device %s %s",
              device,
              errbuf);
    }

    // only get inbound data, should probably be a flag on the probe conf
    // currently unsupported by winpcap
    if(pcap_setdirection(pPcapHandle, PCAP_D_IN) < 0)
    {
      throw Toolkit::Exception{"could not set direction on device %s %s",
          device,
          errbuf};
    }
    // unlock it now, so we don't deadlock the thread, we're done with our changes anyway
    context.mutex.unlock();
    
    // start pcap read thread
    context.thread = std::thread(&Probe::readDevice,this,&context);

  }
  
}

void OpenTestPoint::IPTraffic::Probe::stop()
{
  for(auto & context: vContexts_){
    context.mutex.lock();
    
    if(context.pPcapHandle){
      // stop the capture
      pcap_close(context.pPcapHandle);
      context.pPcapHandle = NULL;
      //stop the thread
      pthread_cancel(context.thread.native_handle());
      context.thread.join();
    }
  }
}

void OpenTestPoint::IPTraffic::Probe::destroy()
{}


OpenTestPoint::ProbeData OpenTestPoint::IPTraffic::Probe::probe()
{
  ProbeData probeData{};

  char addr[16] = {};

  auto msg = OpenTestPoint::Measurement_pcap_tables_ipv4_udp{};

  auto pReceive = msg.mutable_receive();

  pReceive->add_labels("Device");
  pReceive->add_labels("Src");
  pReceive->add_labels("Dst");
  pReceive->add_labels("Port");
  pReceive->add_labels("Rx Bytes");
  pReceive->add_labels("Rx Packets");

  for(auto & context: vContexts_){
    context.mutex.lock();

    for(const auto & entry : context.store)
    {
      auto pRow = pReceive->add_rows();

      auto pValue = pRow->add_values();

      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_STRING);

      pValue->set_svalue(context.sDevice);

      pValue = pRow->add_values();

      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_STRING);

      inet_ntop(AF_INET,
                &std::get<0>(entry.first),
                addr,
                sizeof(addr));

      pValue->set_svalue(addr);

      pValue = pRow->add_values();

      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_STRING);

      inet_ntop(AF_INET,
                &std::get<1>(entry.first),
                addr,
                sizeof(addr));

      pValue->set_svalue(addr);

      pValue = pRow->add_values();

      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_UINTEGER);

      pValue->set_uvalue(ntohs(std::get<2>(entry.first)));

      pValue = pRow->add_values();

      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_UINTEGER);

      pValue->set_uvalue(std::get<0>(entry.second));

      pValue = pRow->add_values();

      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_UINTEGER);

      pValue->set_uvalue(std::get<1>(entry.second));
    }
    context.mutex.unlock();
  }
  

  std::string sBlob{};

  msg.SerializeToString(&sBlob);


  probeData.push_back(std::make_tuple("IPTraffic.Tables.IPv4.UDP",
                                      std::move(sBlob),
                                      msg.description().name(),
                                      msg.description().module(),
                                      msg.description().version()));

  return probeData;
}

OpenTestPoint::IPTraffic::Probe::~Probe()
{}

void OpenTestPoint::IPTraffic::Probe::readDevice(ProbeContext * pc)
{
  const std::uint8_t * buf = NULL;

  struct pcap_pkthdr *pcap_hdr = NULL;

  int iPcapResult{};

  while(pc->pPcapHandle)
    {
      // get frame, blocks here
      iPcapResult = pcap_next_ex(pc->pPcapHandle, &pcap_hdr, &buf);

      // error
      if(iPcapResult < 0)
        {
          OPENTESTPOINT_PROBESERVICE_LOG_ERROR(pProbeService_,
                                               "pcap_next_ex error %s",
                                               pcap_geterr(pc->pPcapHandle));

          // done
          break;
        }
      // time out
      else if(iPcapResult == 0)
        {
          continue;
        }
      // success
      else if(iPcapResult == 1)
        {
          if(ETHER_IS_VALID_LEN(pcap_hdr->caplen))
            {
              // eth header
              const ether_header * pEthHeader = reinterpret_cast<const ether_header *>(buf);

              switch(ntohs(pEthHeader->ether_type))
                {
                case ETHERTYPE_IP:
                  {
                    const iphdr * pIPHeader =
                      reinterpret_cast<const iphdr *>(buf + ETHER_HDR_LEN);

                    switch(pIPHeader->protocol)
                      {
                      case IPPROTO_UDP:
                        {
			  // ihl in units of 32-bit words. convert to bytes.
                          const udphdr * pUDPHeader =
                            reinterpret_cast<const udphdr *>(buf + ETHER_HDR_LEN  + (pIPHeader->ihl*4));


                          pc->mutex.lock();

                          auto iter = pc->store.find(std::make_tuple(
                                    pIPHeader->saddr,
                                    pIPHeader->daddr,
                                    pUDPHeader->dest));

                          if(iter != pc->store.end())
                            {
                              // bytes
                              std::get<0>(iter->second) += ntohs(pUDPHeader->len);

                              // packets
                              ++std::get<1>(iter->second);
                            }
                          else
                            {
                              pc->store.insert({std::make_tuple(pIPHeader->saddr,
                                                             pIPHeader->daddr,
                                                             pUDPHeader->dest),
                                    std::make_tuple(ntohs(pUDPHeader->len),1)});
                            }

                          pc->mutex.unlock();

                          break;
                        }
                      }
                  }
                }
            }
        }
    }
}

DECLARE_PROBEPLUGIN(OpenTestPoint::IPTraffic::Probe)
