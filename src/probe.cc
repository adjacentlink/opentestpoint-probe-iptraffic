/*
 * Copyright (c) 2017 - Adjacent Link LLC, Bridgewater, New Jersey
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 * * Neither the name of Adjacent Link LLC nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * See toplevel COPYING for more information.
 */

#include "probe.h"
#include "otestpoint/toolkit/exception.h"
#include "otestpoint/toolkit/stringto.h"
#include "otestpoint/probeserviceuser.h"
#include "iptraffic.pb.h"

#include <libxml/parser.h>
#include <libxml/xmlschemas.h>
#include <pthread.h>
#include <net/ethernet.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <arpa/inet.h>

namespace
{
  const int PCAP_SNAPLEN   = 0xFFFF;
  const int PCAP_PROMISC   = 1;
  const int PCAP_IMMEDIATE = 1;

  const char * pzSchema="\
<?xml version='1.0' encoding='UTF-8' standalone='yes'?>\
<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'>\
  <xs:simpleType name='YesNoType'>\
    <xs:restriction base='xs:token'>\
      <xs:enumeration value='yes'/>\
      <xs:enumeration value='no'/>\
    </xs:restriction>\
  </xs:simpleType>\
  <xs:element name='probe-iptraffic'>\
    <xs:complexType>\
      <xs:sequence>\
        <xs:element name='device' maxOccurs='unbounded' minOccurs='1'>\
          <xs:complexType>\
            <xs:simpleContent>\
              <xs:extension base='xs:string'>\
                <xs:attribute type='xs:string' name='name' use='required'/>\
              </xs:extension>\
            </xs:simpleContent>\
          </xs:complexType>\
        </xs:element>\
      </xs:sequence>\
      <xs:attribute name='resetOnSend' type='YesNoType' use='optional' default='no'/>\
    </xs:complexType>\
  </xs:element>\
</xs:schema>";
}


OpenTestPoint::IPTraffic::Probe::Probe(ProbeIndex probeIndex):
  ProbePlugin{probeIndex},
  vContexts_{}
{}

OpenTestPoint::ProbeNames
OpenTestPoint::IPTraffic::Probe::initialize(const std::string & sConfigurationFile)
{
  LIBXML_TEST_VERSION;

  xmlDocPtr pSchemaDoc{xmlReadMemory(pzSchema,
                                     strlen(pzSchema),
                                     "file:///probe-iproute.xsd",
                                     NULL,
                                     0)};

  if(!pSchemaDoc)
    {
      throw Toolkit::Exception{"unable to open schema"};
    }

  xmlSchemaParserCtxtPtr pParserContext{xmlSchemaNewDocParserCtxt(pSchemaDoc)};

  if(!pParserContext)
    {
      throw Toolkit::Exception{"bad schema context"};
    }

  xmlSchemaPtr pSchema{xmlSchemaParse(pParserContext)};

  if(!pSchema)
    {
      throw Toolkit::Exception{"bad schema parser"};
    }

  xmlSchemaValidCtxtPtr pSchemaValidCtxtPtr{xmlSchemaNewValidCtxt(pSchema)};

  if(!pSchemaValidCtxtPtr)
    {
      throw Toolkit::Exception{"bad schema valid context"};
    }

  xmlSchemaSetValidOptions(pSchemaValidCtxtPtr,XML_SCHEMA_VAL_VC_I_CREATE);

  xmlDocPtr pDoc = xmlReadFile(sConfigurationFile.c_str(),nullptr,0);

  if(xmlSchemaValidateDoc(pSchemaValidCtxtPtr, pDoc))
    {
      throw Toolkit::Exception{"invalid document"};
    }

  xmlNodePtr pRoot = xmlDocGetRootElement(pDoc);
  // See if we've been configure to reset the tables when we emit
  xmlChar* reset = xmlGetProp(pRoot, (const xmlChar *) "resetOnSend");
  if (reset != NULL) {
    OPENTESTPOINT_PROBESERVICE_LOG_DEBUG(pProbeService_,
            "resetOnSend defined to %s",
            reset);

    // parse it
    resetOnSend = xmlStrEqual(reset, (const xmlChar *)"yes");
  }  
  OPENTESTPOINT_PROBESERVICE_LOG_INFO(pProbeService_,
          resetOnSend?"we will reset the tables on each send":"we will not reset the tables on send");
    
  
  xmlNodePtr pChild = pRoot->xmlChildrenNode;
  xmlChar * pDeviceName = NULL;

  mutex_.lock();
  
  while(pChild != NULL) {
    if ((!xmlStrcmp(pChild->name, (const xmlChar *)"device"))) {
      pDeviceName = xmlGetProp(pChild,(const xmlChar *) "name");
      ProbeContext pc(std::string(reinterpret_cast<const char *>(pDeviceName)));
      vContexts_.push_back(pc);
      
      // lDevices_.push_back(reinterpret_cast<const char *>(pDeviceName));
      xmlFree(pDeviceName);
    }
    pChild = pChild->next;
    
  }
  mutex_.unlock();
  
  xmlFreeDoc(pDoc);

  // To-Do, check this name is accurate
  probeNames_.push_back("IPTraffic.Tables.IPv4.UDP");
  probeNames_.push_back("IPTraffic.Tables.Ether");

  for(auto const& context: vContexts_){
    OPENTESTPOINT_PROBESERVICE_LOG_INFO(pProbeService_,
            "creating IPTraffic probe on %s",
            context.sDevice.c_str());
  }
  

  return probeNames_;
}

void OpenTestPoint::IPTraffic::Probe::start()
{
  char errbuf[PCAP_ERRBUF_SIZE]={};

  // open pcap handle
  for(auto & context: vContexts_){
    context.mutex.lock();
    
    const char* device = context.sDevice.c_str();

    pcap_t * pPcapHandle = pcap_create(device, errbuf);
    if(pPcapHandle  == NULL )
    {
      throw Toolkit::Exception{"could not open device:%s %s",
          device,
          errbuf};
    }
    // Set the settings we want to run with
    pcap_set_snaplen(pPcapHandle, PCAP_SNAPLEN);
    pcap_set_promisc(pPcapHandle, PCAP_PROMISC);
    // immediate mode disables buffering of packets
    pcap_set_immediate_mode(pPcapHandle, PCAP_IMMEDIATE);

    // Once we've set all the settings we want, we need to activate it
    int rc = pcap_activate(pPcapHandle);
    if(rc < 0){
      // an error ocurred
      pcap_close(pPcapHandle);
      throw Toolkit::Exception{"could not activate the packet capture on device %s: %s",
          device,
          pcap_statustostr(rc)};
    }
    if(rc > 0){
      // A warning was issued, log it and keep going.
      OPENTESTPOINT_PROBESERVICE_LOG_INFO(pProbeService_,
              "Warning from libpcap on activating capture on %s: %s",
              device,
              pcap_statustostr(rc));
    }
    

    // set datalink type, this covers 10/100/1000
    if(pcap_set_datalink(pPcapHandle, DLT_EN10MB) < 0)
    {
      OPENTESTPOINT_PROBESERVICE_LOG_INFO(pProbeService_,
              "could not set datalink type on device %s %s",
              device,
              errbuf);
    }

    // only get inbound data, should probably be a flag on the probe conf
    // currently unsupported by winpcap
    if(pcap_setdirection(pPcapHandle, PCAP_D_IN) < 0)
    {
      throw Toolkit::Exception{"could not set direction on device %s %s",
          device,
          errbuf};
    }

    // no need for an "else" since the ifs throw
    context.pPcapHandle=pPcapHandle;

    // unlock it now, so we don't deadlock the thread, we're done with our changes anyway
    context.mutex.unlock();
    
    // start pcap read thread
    context.thread = std::thread(&Probe::readDevice,this,&context);

  }
  
}

void OpenTestPoint::IPTraffic::Probe::stop()
{
  for(auto & context: vContexts_){
    context.mutex.lock();
    
    if(context.pPcapHandle){
      // stop the capture
      pcap_close(context.pPcapHandle);
      context.pPcapHandle = NULL;
      //stop the thread
      pthread_cancel(context.thread.native_handle());
      context.thread.join();
    }
  }
}

void OpenTestPoint::IPTraffic::Probe::destroy()
{}


OpenTestPoint::ProbeData OpenTestPoint::IPTraffic::Probe::probe()
{
  ProbeData probeData{};

  char addr[18] = {};

  auto udpMsg = OpenTestPoint::Measurement_pcap_tables_ipv4_udp{};
  auto etherMsg = OpenTestPoint::Measurement_pcap_tables_ether{};

  auto udpReceive = udpMsg.mutable_receive();

  udpReceive->add_labels("Device");
  udpReceive->add_labels("Src");
  udpReceive->add_labels("Dst");
  udpReceive->add_labels("Port");
  udpReceive->add_labels("Rx Bytes");
  udpReceive->add_labels("Rx Packets");

  auto etherReceive = etherMsg.mutable_receive();

  etherReceive->add_labels("Device");
  etherReceive->add_labels("Src");
  etherReceive->add_labels("Dst");
  etherReceive->add_labels("Rx Packets");

  for(auto & context: vContexts_){
    context.mutex.lock();

    for(const auto & entry : context.store.UDP)
    {
      auto pRow = udpReceive->add_rows();
      // Interface name
      auto pValue = pRow->add_values();
      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_STRING);
      pValue->set_svalue(context.sDevice);

      // Source IP address
      pValue = pRow->add_values();
      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_STRING);
      inet_ntop(AF_INET,
                &entry.first.src_ip,
                addr,
                sizeof(addr));
      pValue->set_svalue(addr);

      // Destination IP address
      pValue = pRow->add_values();
      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_STRING);
      inet_ntop(AF_INET,
                &entry.first.dst_ip,
                addr,
                sizeof(addr));
      pValue->set_svalue(addr);

      // Destination Port
      pValue = pRow->add_values();
      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_UINTEGER);
      pValue->set_uvalue(ntohs(entry.first.dst_port));

      // Total Bytes
      pValue = pRow->add_values();
      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_UINTEGER);
      pValue->set_uvalue(entry.second.bytes);

      // Total Packets
      pValue = pRow->add_values();
      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_UINTEGER);
      pValue->set_uvalue(entry.second.packets);
    }
    if(resetOnSend){
      context.store.UDP.clear();
    }
    
    for(const auto & entry : context.store.Ether)
    {
      auto pRow = etherReceive->add_rows();

      // Interface name
      auto pValue = pRow->add_values();
      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_STRING);
      pValue->set_svalue(context.sDevice);

      char saddr[18] = {};
      // Source MAC
      pValue = pRow->add_values();
      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_STRING);
      sprintf(saddr, "%02x:%02x:%02x:%02x:%02x:%02x", 
              (unsigned char)entry.first.ether_shost[0],
              (unsigned char)entry.first.ether_shost[1],
              (unsigned char)entry.first.ether_shost[2],
              (unsigned char)entry.first.ether_shost[3],
              (unsigned char)entry.first.ether_shost[4],
              (unsigned char)entry.first.ether_shost[5]);
      pValue->set_svalue(saddr);

      char daddr[18] = {};
      // destination mac address
      pValue = pRow->add_values();
      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_STRING);
      sprintf(daddr, "%02x:%02x:%02x:%02x:%02x:%02x", 
              (unsigned char)entry.first.ether_dhost[0],
              (unsigned char)entry.first.ether_dhost[1],
              (unsigned char)entry.first.ether_dhost[2],
              (unsigned char)entry.first.ether_dhost[3],
              (unsigned char)entry.first.ether_dhost[4],
              (unsigned char)entry.first.ether_dhost[5]);
      pValue->set_svalue(daddr);

      // number of packets received
      pValue = pRow->add_values();
      pValue->set_type(OpenTestPoint::MeasurementTable::Measurement::TYPE_UINTEGER);
      pValue->set_uvalue(entry.second.packets);

      OPENTESTPOINT_PROBESERVICE_LOG_DEBUG(pProbeService_,
              "Sending %s|%s|%s|%lu",
              context.sDevice.c_str(), saddr, daddr, entry.second.packets);
      
    }
    if(resetOnSend){
      context.store.Ether.clear();
    }
    
    context.mutex.unlock();
  }
  

  std::string udpBlob{};

  udpMsg.SerializeToString(&udpBlob);
  probeData.push_back(std::make_tuple("IPTraffic.Tables.IPv4.UDP",
                                      std::move(udpBlob),
                                      udpMsg.description().name(),
                                      udpMsg.description().module(),
                                      udpMsg.description().version()));

  std::string etherBlob{};
  etherMsg.SerializeToString(&etherBlob);
  probeData.push_back(std::make_tuple("IPTraffic.Tables.Ether",
                                      std::move(etherBlob),
                                      etherMsg.description().name(),
                                      etherMsg.description().module(),
                                      etherMsg.description().version()));

  return probeData;
}

OpenTestPoint::IPTraffic::Probe::~Probe()
{}

void OpenTestPoint::IPTraffic::Probe::readDevice(ProbeContext * pc)
{
  const std::uint8_t * buf = NULL;

  struct pcap_pkthdr *pcap_hdr = NULL;

  int iPcapResult{};

  while(pc->pPcapHandle)
    {
      // get frame, blocks here
      iPcapResult = pcap_next_ex(pc->pPcapHandle, &pcap_hdr, &buf);

      // error
      if(iPcapResult < 0)
        {
          OPENTESTPOINT_PROBESERVICE_LOG_ERROR(pProbeService_,
                                               "pcap_next_ex error %s",
                                               pcap_geterr(pc->pPcapHandle));

          // done
          break;
        }
      // time out
      else if(iPcapResult == 0)
        {
          continue;
        }
      // success
      else if(iPcapResult == 1)
        {
          if(pcap_hdr->caplen >= ETHER_HDR_LEN)
            {
              // eth header
              const ether_header * pEthHeader = reinterpret_cast<const ether_header *>(buf);
              // scope block for storing the Ethernet frame data
              {
                pc->mutex.lock();
                ProbeContext::etherKey key(pEthHeader->ether_shost, pEthHeader->ether_dhost);
                auto iter = pc->store.Ether.find(key);
                if(iter != pc->store.Ether.end()){
                  iter->second.packets += 1;
                }
                else{
                  char addr[18] = {};
                  sprintf(addr, "%02x:%02x:%02x:%02x:%02x:%02x", 
                          (unsigned char)key.ether_shost[0],
                          (unsigned char)key.ether_shost[1],
                          (unsigned char)key.ether_shost[2],
                          (unsigned char)key.ether_shost[3],
                          (unsigned char)key.ether_shost[4],
                          (unsigned char)key.ether_shost[5]);

                  OPENTESTPOINT_PROBESERVICE_LOG_INFO(pProbeService_,
                          "New mac source %s",
                          addr);
                  ProbeContext::etherValue value;
                  value.packets=1;
                  pc->store.Ether.insert({key,value});
                }
              
                pc->mutex.unlock();
              }
              
              
              switch(ntohs(pEthHeader->ether_type))
                {
                case ETHERTYPE_IP:
                  {
                    const iphdr * pIPHeader =
                      reinterpret_cast<const iphdr *>(buf + ETHER_HDR_LEN);

                    switch(pIPHeader->protocol)
                      {
                      case IPPROTO_UDP:
                        {
			  // ihl in units of 32-bit words. convert to bytes.
                          const udphdr * pUDPHeader =
                            reinterpret_cast<const udphdr *>(buf + ETHER_HDR_LEN  + (pIPHeader->ihl*4));


                          pc->mutex.lock();

                          ProbeContext::udpKey key(pIPHeader->saddr,
                                  pIPHeader->daddr,
                                  pUDPHeader->dest);
                          
                          auto iter = pc->store.UDP.find(key);

                          if(iter != pc->store.UDP.end())
                            {
                              iter->second.bytes += ntohs(pUDPHeader->len);
                              ++iter->second.packets;
                            }
                          else
                          {
                            ProbeContext::udpValue value;
                            value.bytes = ntohs(pUDPHeader->len);
                            value.packets = 1;
                            
                              pc->store.UDP.insert({key,value});
                            }

                          pc->mutex.unlock();

                          break;
                        }
                      }
                  }
                }
            }
        }
    }
}

DECLARE_PROBEPLUGIN(OpenTestPoint::IPTraffic::Probe)
